
# 类

在Java中，类文件是以.java为后缀的代码文件

**在每个类文件中最多只允许出现一个public类，当有public类的时候，类文件的名称必须和public类的名称相同**，若不存在public，则类文件的名称可以为任意的名称（当然以数字开头的名称是不允许的）。

# this/super

`this`是自身的一个对象，代表对象本身，可以理解为：**指向对象本身的一个指针**。

- 当形参与成员名字重名，用this来区分；
- 可以调用另外的构造函数；

`super`是关键字，用在子类中，目的是**访问直接父类中的成员和方法**，注意是直接父类。
注意,当子类构造函数引用父类构造方法时,**一定要放在函数的首行**

# 接口类和抽象类

## 抽象类

在Java中，可以通过两种形式来体现OOP的抽象：接口和抽象类

抽象方法: 抽象方法是一种特殊的方法：它只有声明，而没有具体的实现。抽象方法的声明格式为:

```
abstract void fun();
```

抽象类必须在类前用abstract关键字修饰,抽象类中必定含有抽象方法

```
[public] abstract class ClassName {
    abstract void fun();
}
```

抽象类和普通类的主要有三点区别：

1）抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public。

2）抽象类不能用来创建对象；

3）如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。

## 接口

定义:

```
[public] interface InterfaceName {
 
}
```

接口中可以含有 变量和方法。但是要注意，接口中的变量会被隐式地指定为public static final变量（并且只能是public static final变量，用private修饰会报编译错误），而方法会被隐式地指定为public abstract方法且只能是public abstract方法（用其他关键字，比如private、protected、static、 final等修饰会报编译错误），并且接口中所有的方法不能有具体的实现，也就是说，接口中的方法必须都是抽象方法。从这里可以隐约看出接口和抽象类的区别，
**接口是一种极度抽象的类型，它比抽象类更加“抽象”，并且一般情况下不在接口中定义变量**。

实现:

```
class ClassName implements Interface1,Interface2,[....]{
}
```

允许一个类遵循多个特定的接口。如果一个非抽象类遵循了某个接口，就必须实现该接口中的所有方法。对于遵循某个接口的抽象类，可以不实现该接口中的抽象方法。

## 区别:

### 语法区别:

1）抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法；
2）抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；
3）接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；
4）一个类只能继承一个抽象类，而一个类却可以实现多个接口。

### 设计层面的区别:

抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象.

1）抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。举个简单的例子，飞机和鸟是不同类的事物，但是它们都有一个共性，就是都会飞。那么在设计的时候，可以将飞机设计为一个类Airplane，将鸟设计为一个类Bird，但是不能将 飞行 这个特性也设计为类，因此它只是一个行为特性，并不是对一类事物的抽象描述。此时可以将 飞行 设计为一个接口Fly，包含方法fly( )，然后Airplane和Bird分别根据自己的需要实现Fly这个接口。然后至于有不同种类的飞机，比如战斗机、民用飞机等直接继承Airplane即可，对于鸟也是类似的，不同种类的鸟直接继承Bird类即可。从这里可以看出，继承是一个 "是不是"的关系，而 接口 实现则是 "有没有"的关系。如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而接口实现则是有没有、具备不具备的关系，比如鸟是否能飞（或者是否具备飞行这个特点），能飞行则可以实现这个接口，不能飞行就不实现这个接口。

2）设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。什么是模板式设计？最简单例子，大家都用过ppt里面的模板，如果用模板A设计了ppt B和ppt C，ppt B和ppt C公共的部分就是模板A了，如果它们的公共部分需要改动，则只需要改动模板A就可以了，不需要重新对ppt B和ppt C进行改动。而辐射式设计，比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。也就是说对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。
　　
# 继承

使用`extends`来表示,如果没有明确指出要继承的类，就总是隐式地从根类Object进行继承

# final/static

## final

- final类不能被继承，没有子类，final类中的方法默认是final的。
- final方法不能被子类的方法覆盖，但可以被继承。
- final成员变量表示常量，只能被赋值一次，赋值后值不再改变。
- final不能用于修饰构造方法。
- 当函数参数为final类型时，你可以读取使用该参数，但是无法改变该参数的值

## static

**Java语言中没有全局变量的概念**,static表示“全局”或者“静态”的意思，用来修饰成员变量和成员方法，也可以形成静态static代码块

 **被static修饰的成员变量和成员方法独立于该类的任何对象**,用public修饰的static成员变量和成员方法本质是全局变量和全局方法，当声明它类的对象时，不生成static变量的副本，而是类的所有实例共享同一个static变量。
 
static变量前可以有private修饰，表示这个变量可以在类的静态代码块中，或者类的其他静态成员方法中使用，但是不能在其他类中通过类名来直接引用，这一点很重要.

**private是访问权限限定，static表示不要实例化就可以使用**
